### 2-4const限定符
1. 使用过const的小伙伴一定感觉到了const的恶意(我指的是和指针的连用)
2. 当我们需要一个常量,也就是不能被修改,而且固定大小的变量时候,我们应该将这种变量定义为常量
3. 需要注意的是,const变量也是无法修改的,所以必须初始化
4. 但是和引用不一样的地方就是,引用只能用对象初始化,const变量可以使用任意的表达式作为初始化值
5. 这里还有一些使用上的注意,默认const定义的变量是单编译单元有效的.这和static变量是有相同的性质的
6. 所以你想在多个文件中使用一个const变量,必须加入extern关键字来声明并且初始化定义
7. 然后在其他编译单元要使用的话,你需要加入extern const 类型 声明符 来声明使用变量.
8. 如果你不这样做的话,在每个编译单元中定义相同的const变量,那么这个只是多份名字相同的变量而已,地址都不一样
9. 这个编译单元重复定义其实是c++保证的,因为const默认就是单个编译单元有效,和static类似的效果
加※:最后,还是强调一下,要在多个编译单元中共享const对象,则需要在所有相关定义还是声明上加上extern关键字


### 广大同胞们注意了,const升级教程来了(就是const引用该如果正确的理解呢)
1. 根据书籍所描述,我发现有一些地方是困惑的
2. 首先你们想想,引用是不是本身就是一个常量
3. 所以说,const引用只能说的是指向的量是常量(一般叫做常量引用)
4. 再者说,我们的普通引用只可以使用对象进行初始化,但是const却可以使用任意的表达式,哪怕指向的量不是常量也行(这也是引用不和原对象类型匹配的一种特例)
5. 指向常量的引用,毋庸置疑,那么就不会发生改变
6. 但是什么呢,如果你使用的是一个非常量的量来初始化常量引用的话,不好意思,你本身的常量引用无法修改这个值,但是其他的途径可以修改,那么也就会造成常量引用的值也会发生改变.
7. 但是呢,你如果要通过一些表达式,或者其他类型,(也就是经过默认类型转换可以实现类型变换)那么,c++就会使用一个临时量来初始化这个变量.
8. 那么说明这个const 引用还是很复杂的.清楚了这一点,你就可以放心的去使用const引用了(注意:const 引用没有顶层和底层const之分)
9. 以上的描述是我自己做实验做出来的.没错误的

### 那么接下来就是const 与 指针了  (这个我给你说,就复杂多了)
1. 首先明确一点,那就是const 指针有指向常量的指针,还有本身就是常量的指针
2. 指向常量的指针,这个指向的不一定是常量(这也是2.1描述指针和指向的对象类型一致的问题的特例),所以说你可以使用一个非常量的地址来初始化一个指向常量的指针
3. 通过以上的描述,那我们可以得出,那就是指向常量的指针和指向常量的引用,这些指向常量就是一个幌子,实际上,自以为是指向了常量而已,自己确定自己不会修改人家的值而已
4. 定义指向常量的指针 const int *p;
5. 定义指向常量的常量指针 const int *const p;
6. 识别const和指针和引用类型的符合类型的结合,也是需要从右到左去看.
7. 还有需要注意的一个点就是常量类型的地址只能常量指针来指向.

### 顶层const
1. 分清楚定层const和底层const是很有必要的
2. 顶层const代表变量本身是常量
3. 底层const代表的是指向的是常量
4. 赋值运算的时候必须是考虑到底层const,因为一个变量不具有底层const属性而指向了一个具有底层const属性的变量,那么这是非法的

### constexpr 和常量表达式
1. 这个和const是有一定的去别的
2. 是指的是值不会改变,而且在编译期间既可以算出来的表达式
3. 字面值是常量表达式
4. 使用常量表达式初始化的const对象也是常量表达式
5. 后续会提到c++中有一些地方需要用到常量表达式
6. 一般你要认为一个变量是常量表达式,那你就定义为constexpr
7. 这也是避免你在使用常量的时候造成里面的值会发生改变

	int i = 0;
	const int &ri = i;
	constexpr int &rri = i;

上面的代码就是一个很好的例子,第二行的是通过编译的 第三行就不行,因为他就不是一个常量表达式
这样就避免了你在使用的过程中,i发生了改变,你的ri也发生了改变,这可不是你想要的
我总感觉这是c++设计者之前没有考虑到const 常量初始化的定义出的bug

8. 字面值类型可以定义为constexpr
9. 一般函数体内的变量不能初始化一个constexpr,因为在函数内部的变量没有固定的内存地址.函数外的变量可以初始化一个constexpr对象
10. 需要注意的是,值得注意的是constexpr定义的指针,只和指针有关,和指针指向的对象没有关系
比如: constexpr int *p; 这就是一个常量指针
	  constexpr const int *p; 这就是一个指向常量的常量指针

####  最后总结一下constexpr,其实constexpr就是用来验证编译时候你定义的变量是不是真的常量
